[Accueil](./index.md) > [4M](./acceuil4M.md#projet-7--mouvement-avec-mission)

# üìö Notes : plusieurs t√¢ches en parall√®le (la multi-t√¢che) - synchroniser avec millis()

## Introduction

Plusieurs programmes que nous avons vus jusqu'√† pr√©sent utilisent la fonction `delay()` pour g√©rer le temps entre les diff√©rentes actions du robot. Cepend√†nt, cette fonction **bloque le programme** pendant le temps sp√©cifi√©, ce qui peut √™tre probl√©matique si le robot doit effectuer plusieurs t√¢ches en m√™me temps - comme lire des capteurs, contr√¥ler des moteurs, clignoter des DEL. Dans ce cas, il est pr√©f√©rable d'utiliser une autre approche pour g√©rer le temps, notamment en utilisant la fonction `millis()`. Par contre, cette fonction vient avec une nouvelle logique de gestion des d√©lais qui est important de comprendre.

## En bref

**bloquer** : arr√™ter l'ex√©cution du programme pour un certain temps, notamment avec `delay()`

**multi-t√¢che** : g√©rer plusieurs t√¢ches en m√™me temps. Avec certain mat√©riel, c'est possible de lancer plusieurs fils d'ex√©cution en parall√®le (comme Scratch), mais il y a un seul fil d'ex√©cution possible avec Arduino. Pour faire de la multi-t√¢che avec Arduino, on doit g√©rer les t√¢ches en s√©quence tout en v√©rifier si c'est le moment de lancer une instruction sp√©cifique.

**millis()** : fonction qui retourne le nombre de millisecondes √©coul√©es depuis le d√©marrage du programme. On peut l'utiliser pour g√©rer les intervalles de temps sans bloquer le programme.

**variable locale** : variable d√©clar√©e √† l'int√©rieur d'une fonction et qui n'est accessible que dans cette fonction. Elle est d√©truite √† la fin de la fonction sauf si elle est d√©clar√©e `static`.

## Exemple - robot qui dance en tournant avec moustaches comme signal d'arr√™t

Imagine un robot qui fait 3 tours √† gauche et ensuite 3 tours √† droite infiniment, sauf si une de ses moustaches est enfonc√©e. √Ä ce moment, il devrait arr√™ter de bouger.

Pr√©sumant qu'on impl√©mente le code pour ce comportement comme une machine √† √©tats finis, le diagramme d'√©tats est plus complexe que l'exemple dans l'introduction aux FSM : il inclut une boucle (entre les √©tats LEFT et RIGHT) et des embranchements (quand le capteur est enfonc√©).

![diagramme d'√©tats multi-t√¢che](./images/p7/fsm_multi.drawio.png)

## Solution avec `delay()`

Avec ce que nous avons vus jusqu'√† pr√©sent, incluant la biblioth√®que personnelle `RobotDrive`, un exemple de code pour le robot de l'exemple pourrait ressembler √† ceci :

```cpp
#include <Arduino.h>
#include <RobotDrive.h>

/*
D√âFINIR LES CONNEXIONS MAT√âRIELLES
*/

const int millisForOneTurn = 2100; // √† calibrer; avec turnLeft() et turnRight()

const int rightWhisker = 7;
const int pressed = LOW; // ou 0

/*
D√âFINIR LES √âTATS DU ROBOT
*/

enum class States {
  SETUP,
  LEFT,
  RIGHT,
  STOP
};

States currentState = States::SETUP;

void setup() {
  setRobotDrivePins(10, 11);
  pinMode(rightWhisker, INPUT);
  currentState = States::LEFT;
}

void loop() {
  /* LIRE LES CAPTEURS */
  if (digitalRead(rightWhisker) == pressed) {
    currentState = States::STOP;
  }

  /* G√âRER L'√âTAT */
  switch (currentState) {
  case States::LEFT:
    turnLeft();
    delay(3 * millisForOneTurn);   // fait 3 tours √† gauche
    currentState = States::RIGHT;  // change l'√©tat
    break;
  case States::RIGHT:
    turnRight();
    delay(3 * millisForOneTurn);  // fait 3 tours √† droite
    currentState = States::LEFT;  // change l'√©tat
    break;
  case States::STOP:
    stop();                       // √©tat final (pas de transition)
    break;
  }
}
```

### Analyse

1. Cr√©er un nouveau projet PlatformIO nomm√© `multi-tasking`.
1. Configurez votre projet en lui ajoutant les biblioth√®ques n√©cessaires :
   1. Ajoutez la ligne suivante √† son fichier `platformio.ini` : `lib_deps = arduino-libraries/Servo@^1.2.1` afin d'ajouter la biblioth√®que externe `Servo` √† votre projet.
   1. Copier le dossier `RobotDrive` de vos biblioth√®ques personnelles dans le dossier `lib` du projet.
1. Copiez le code ci-dessus dans le fichier `/src/main.cpp` et compilez-le pour v√©rifier qu'il n'y a pas d'erreurs de transcription.
1. T√©l√©versez le code vers votre base robotique √† entra√Ænement diff√©rentiel et observez le comportement du robot.
1. Est-ce que vous pouvez fiablement arr√™ter le robot en enfon√ßant une moustache?
   - √Ä quel moment est-ce que le robot semble r√©agir √† l'enfoncement de la moustache?
   - Est-ce que le robot s'arr√™te avant de finir les 3 rotations √† gauche ou √† droite?
   - Si la moustache n'est pas enfonc√©e au moment de la transition entre les directions, est-ce que le contact influence le programme?

## Introduction √† `millis()`

Avec la solution pr√©c√©dente, le probl√®me est que le programme est bloqu√© durant chaque `delay()`. Notamment, la boucle `loop()` n'est pas en train de se r√©p√©ter alors on n'arrive pas √† l'instruction pour lire les capteurs. Si la moustache est enfonc√©e pendant un `delay()`, le robot n'est pas en mesure de le d√©tecter.

La solution est de remplacer le code qui bloque le programme (`delay()`) par un code qui lui permet d'it√©rer en continu tout en respectant les d√©lais voulus. Heureusement, il y a la fonction `millis()` qui nous donnne des lectures de chronom√®tre en millisecondes depuis le lancemement du programme.

La logique de base pour remplacer `delay()` par `millis()` est la suivante :

```
Est-ce la diff√©rence entre maintenant et le temps de r√©f√©rence est plus grande que le d√©lai voulu?
    Si oui, faire la chose voulue et mettre √† jour le temps de r√©f√©rence.
    Si non, fait rien.
```

√áa ne semble peut-√™tre pas majeur comme changement, mais ce l'est! Le temps n√©cessaire pour passer √† travers cette s√©lection est minime et le code suivant s'ex√©cute imm√©diatement. Quand ce code se trouve dans une boucle, tout le code de la boucle a le temps de se r√©p√©ter plusieurs fois avant que le d√©lai soit atteint et la t√¢che voulue est ex√©cut√©e.

On atteint alors la possibilit√© d'une vraie multi-t√¢che, o√π plusieurs t√¢ches peuvent √™tre g√©r√©es en m√™me temps.

### Impl√©mentation de base

Avec la syntaxe Arduino, l'algorithme g√©n√©ral ci-dessus donne le code de base suivant :

```cpp
#include <Arduino.h>

const int waitTime = 3000; // 3 secondes, par exemple
unsigned long referenceTime = millis();

void setup() {}

void loop() {
  if (millis() - referenceTime >= waitTime) {
    // code pour la t√¢che voulue
    referenceTime = millis(); // mettre √† jour le temps de r√©f√©rence
  }
}
```

- Notre temps de r√©f√©rence est de type `unsigned long` pour pouvoir contenir les valeurs de 0 √† 4,294,967,295 (en millisecondes, c'est environ 50 jours). Un `unsigned int` ne suffirait pas pour des d√©lais de plus de 65 secondes!
- L'appelle √† `millis()` nous donne le temps actuel en millisecondes depuis le lancement du programme. On l'utilise chaque fois qu'on a besoin du temps (comme pour initialiser `referenceTime`, pour calculer la diff√©rence entre maintenant et `referenceTime` et pour r√©initialiser `referenceTime`).

### Impl√©mentation plus robuste

Parce que le code dans `loop()` peut devenir assez complexe avec plusieurs t√¢ches, on tend √† √©crire une fonction sp√©cifique pour chaque t√¢che. Cela nous donne la possibilit√© de g√©rer les variables li√©es au d√©lai enti√®rement √† l'int√©rieur de la fonction, ce qui rend le code plus lisible et plus facile √† maintenir.

Voici l'exemple pr√©c√©dent r√©√©crit avec une fonction pour la t√¢che :

```cpp
#include <Arduino.h>

void doTask(); // d√©claration avanc√©e de la fonction

void setup() {}

void loop() {
  doTask();
}

void doTask() {
  static const int waitTime = 3000; // 3 secondes, par exemple
  static unsigned long referenceTime = millis();

  if (millis() - referenceTime >= waitTime) {
    // code pour la t√¢che voulue
    referenceTime = millis(); // mettre √† jour le temps de r√©f√©rence
  }
}
```

- Si on d√©finit la fonction apr√®s `loop()`, on doit d√©clarer la fonction avant `loop()` pour que le compilateur sache qu'elle existe. C'est ce que fait la ligne `void doTask(); // d√©claration avanc√©e de la fonction`.
- Les variables `waitTime` et `referenceTime` sont maintenant des variables locales √† la fonction `doTask()`. Elles sont `static` pour √™tre :
    - d√©clar√©es et initialis√©es une seule fois : quand la fonction est initialement charg√©e en m√©moire
    - conserv√©es entre les appels de la fonction (contrairement √† des variables locales normales qui sont d√©truites √† la fin de la fonction)
- Pour ajouter des t√¢ches suppl√©mentaires, il suffit de copier-coller la fonction `doTask()` sans m√™me changer les noms des varaibles internes √† la fonction, soit les **variables locales**. Parce que ces variables sont seulement accessibles dans la fonction o√π elles sont d√©clar√©es, des variables avec le m√™me nom dans diff√©rentes fonctions ne seront pas confondues.

#### Tester rapidement cette impl√©mentation plus robuste

1. Cr√©ez un nouveau projet PlatformIO nomm√© `millis-test`.
1. Copiez le code ci-dessous dans le fichier `/src/main.cpp` et le transf√©rez vers une carte Arduino (comme celle dans votre robot).
1. V√©rifier que le DEL int√©gr√© clignote toutes les 0.5 secondes.

```cpp
#include <Arduino.h>

void blink();

void setup() {
  pinMode(13, OUTPUT);
  digitalWrite(13, HIGH);
}

void loop() {
  blink();
}

void blink() {
  static const int waitTime = 500; 
  static unsigned long referenceTime = millis();

  if (millis() - referenceTime >= waitTime) {
    digitalWrite(13, !digitalRead(13));
    referenceTime = millis(); // mettre √† jour le temps de r√©f√©rence
  }
}
```

> Notez l'astuce pour la ligne `digitalWrite(13, !digitalRead(13));` : `!` est l'op√©rateur de n√©gation logique qui inverse la valeur d'une variable bool√©enne. Alors chaque fois qu'on passe sur cette instruction, on donne  au DEL (avec `digitalWrite`) l'√©tat inverse de ce qu'il avait (obtenu avec `digitalRead`).

## Solution avec `millis()`

Revenant √† l'exemple du robot qui dance en tournant avec moustaches comme signal d'arr√™t, voici une solution qui utilise `millis()` pour g√©rer les d√©lais :

```cpp
#include <Arduino.h>
#include <RobotDrive.h>

/*
D√âFINIR LES CONNEXIONS MAT√âRIELLES
*/

const int rightWhisker = 7;
const int pressed = LOW; // ou 0

/*
D√âFINIR LES √âTATS DU ROBOT
*/

enum class States {
  SETUP,
  LEFT,
  RIGHT,
  STOP
};

States currentState = States::SETUP;

/*
D√âCLARATIONS AVANC√âES
*/

void spin(States direction);

void setup() {
  setRobotDrivePins(10, 11);
  pinMode(rightWhisker, INPUT);
  turnLeft(); // initialise le mouvement
  currentState = States::LEFT;
}

void loop() {
  /* LIRE LES CAPTEURS */
  if (digitalRead(rightWhisker) == pressed) {
    currentState = States::STOP;
  }

  /* G√âRER L'√âTAT */
  switch (currentState) {
  case States::LEFT:
    spin(currentState);
    currentState = States::RIGHT;
    break;
  case States::RIGHT:
    spin(currentState);
    currentState = States::LEFT;
    break;
  case States::STOP:
    stop();
    break;
  }
}

// change la direction de rotation √† un d√©lai fixe avec millis()
void spin(States direction) {
  static const int waitTime = 3 * 2100; // √† calibrer avec turnLeft() et turnRight()
  static unsigned long referenceTime = millis();

  if (millis() - referenceTime >= waitTime) {
    if (direction == States::LEFT) {
      turnLeft();
    } else {
      turnRight();
    }
    referenceTime = millis(); // mettre √† jour le temps de r√©f√©rence
  }
}
```

- La fonction `spin(States direction)` est utiliser pour `turnLeft()` et `turnRight()` et utilise l'√©tat de la machine √† √©tats fini pass√© en argument pour choisir la bonne instruction de mouvment. Sinon, cette fonction est √©quivalente √† la fonction `doTask()` de l'exemple pr√©c√©dent.
- Parce que notre fonction pour g√©rer les d√©lais attend avant de donner une nouvelle instruction, il faut donner une premi√®re instruction de mouvement dans `setup()` pour initialiser le mouvement. Sinon il faudrait attendre le premier d√©lai avant de voir le robot bouger.

### Analyse

1. Remplacer le code dans `/src/main.cpp` du projet `multi-tasking` que nous avons initialis√© avec une solution utilisant `delay()` par le code ci-dessus.
1. Compilez le code pour v√©rifier qu'il n'y a pas d'erreurs de transcription.
1. T√©l√©versez le code vers votre base robotique √† entra√Ænement diff√©rentiel et observez le comportement du robot.
1. Est-ce que vous pouvez maintenant fiablement arr√™ter le robot en enfon√ßant une moustache?
    - √Ä quel moment est-ce que le robot semble r√©agir √† l'enfoncement de la moustache?
    - Est-ce que le robot s'arr√™te avant de finir les 3 rotations √† gauche ou √† droite?
    - Si la moustache n'est pas enfonc√©e au moment de la transition entre les directions, est-ce que le contact influence le programme?
